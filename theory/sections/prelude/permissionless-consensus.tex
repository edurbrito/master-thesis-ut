Long has been the time when consensus was still on the verge of being considered such a fundamental problem of distributed systems, at least as widely as it is now \cite{pease1980reaching, lamport2019byzantine, lamport1983weak}. Generally, consensus means reaching an agreement between multiple parties in the potential presence of faulty individuals. As per multi-agent systems, interacting over computer networks, consensus is thought to be the result of a coordination effort, such that those parties agree on some value at a given moment. Achieving consensus implies that the system shall be reliable and fault-tolerant. However, the consensus problem has been invariably and evolutionarily limited by some assumptions on the networks and on the roles of its participants. The well-known "secure Byzantine-Fault-Tolerant multiparty consensus systems" that have been designed over the years are usually meant to work only with a set of known participants, faulty or not \cite{castro1999practical}. The other side of the coin is the permissionless consensus challenge, consisting of achieving agreement in an environment where the parties are unknown and untrusted \cite{nakamoto2008bitcoin, buterin2014next}. There are other intrinsic particularities of this type of networks, for example, their openness, and the lack of any kind of central authority, that consequently add another layer of complexity to the problem. The participants are not only unknown and untrusted but can also join or leave the network at any time, freely choosing if they want to participate in the consensus protocol or not. Nevertheless, the problem of permissionless consensus can still be seen as a special case of the more general consensus and can still be formalized in a similar way.

The first theoretical algorithms were designed for synchronous systems, where the communication between the processes is reliable, and the delay is bounded. 
The first practical asynchronous consensus algorithm was later proposed by Castro and Liskov in \cite{castro1999practical}. And naturally, after that work, many other asynchronous consensus algorithms have appeared. However, all of them are based on the assumption that the number of faulty processes is less than a certain threshold. Additionally, the assumption of a known set of participants is also made, as well as their roles in the consensus protocol. These are very strong assumptions that limit the challenges that can be addressed, for instance, with the impossibility of knowing the participants beforehand as they may participate anonymously, or dynamically.

\subsubsection{Proof-of-Work and Proof-of-Stake}

The advancements of the internet more than potentiated the revolution and what we now call the permissionless consensus problem was finally born. Without forgetting the previous attempts, the first practical permissionless consensus algorithm was proposed by Nakamoto in \cite{nakamoto2008bitcoin}. It is a proof-of-work consensus protocol that resembles a "replicated state machine" where the independent participants reach agreement not only about transactional values, but also about their order - naturally forming the underlying structure of what is now known as a blockchain. "Proof-of-work is essentially one-CPU-one-vote" and this is the novelty introduced by Bitcoin \cite{pass2016hybrid,pass2016hybrid2}. The focus shifted for decentralized systems and after proof-of-work many other consensus mechanisms have been proposed, based on different consensus units, being them proof-of-stake, proof-of-space, proof-of-authority, and a chaotic diversity of related ones.

The solution is, nevertheless, not settled and the scientific community has been reasoning about the need for permissionless consensus when there are already well known and established consensus protocols that work in trusted environments \cite{castro1999practical, miller2016honey}. However, even those protocols have their own limitations, not only in terms of trust, fault-tolerance, centrality, permissions, or bottlenecks, but also in terms of scalability \cite{miller2016honey}. Trying to put some effort on decentralization, Byzantine-Fault-Tolerant consensus protocols, or simply BFT protocols, are not known for their performance when the network grows in size. The more participants there are, the more messages need to be exchanged between them, and the more time it takes to reach consensus, even if assuring deterministic finality \cite{decker2016bitcoin}. This is a problem that is not only related to the number of participants, but also to the communication fashion and bandwidth, and the computational capacity of the devices that participate in the consensus protocol. Summing up, the need for permissionless consensus is then justified by the fact that permissioned protocols are not compatible with the requirements of the new generation of distributed systems, especially in the context of blockchain networks. These requirements include dealing with today's sparse networks of anonymously and dynamically participating devices, without interrupting consensus and while battling Sybil attacks \cite{8629877, survey-dist-consensus}. Fundamentally, the permissionless consensus problem is the need for a consensus protocol that can be run in a distributed and decentralized environment, where the participants are unknown and untrusted, and where the network is bigger, sparser and unpredictably less reliable.

\subsubsection{Proof-of-X}